<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>OBS Source</title>
    <style>
        /* Стили из предыдущей версии, все правильно */
    </style>
</head>
<body>
    <div id="message-container">
        <div id="sender"></div>
        <div id="text"></div>
        <div id="progress-bar"></div>
    </div>
    <script>
        const synth = window.speechSynthesis;
        let voices = [];
        function populateVoiceList() { voices = synth.getVoices(); }
        populateVoiceList();
        if (synth.onvoiceschanged !== undefined) synth.onvoiceschanged = populateVoiceList;

        const container = document.getElementById('message-container');
        const senderEl = document.getElementById('sender');
        const textEl = document.getElementById('text');
        const progressBar = document.getElementById('progress-bar');
        
        let ws;
        let currentUtterance = null; // Для отслеживания текущей озвучки

        function connect() { /* ... код подключения WebSocket без изменений ... */ }
        
        function speak(data) {
            // Гарантированно останавливаем любую предыдущую озвучку
            if (synth.speaking) {
                synth.cancel();
            }
            // Сбрасываем анимацию
            container.classList.remove('visible');
            progressBar.style.transition = 'none';
            progressBar.style.transform = 'scaleX(0)';

            // Даем браузеру время на сброс стилей перед новой анимацией
            setTimeout(() => {
                senderEl.textContent = data.sender;
                textEl.textContent = data.text;
                container.classList.add('visible');

                const utterThis = new SpeechSynthesisUtterance(data.text);
                currentUtterance = utterThis;
                const chosenVoice = voices.find(voice => voice.name === data.voiceName);
                utterThis.voice = chosenVoice;

                utterThis.onstart = () => {
                    const estimatedDuration = Math.max(2.5, data.text.length * 0.085);
                    progressBar.style.transition = `transform ${estimatedDuration}s linear`;
                    progressBar.style.transform = 'scaleX(1)';
                };

                utterThis.onend = () => {
                    if (currentUtterance === utterThis) {
                        container.classList.remove('visible');
                        ws.send(JSON.stringify({ type: 'speech_finished' }));
                    }
                };
                
                synth.speak(utterThis);
            }, 100); // Небольшая задержка для стабильности
        }

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'play') {
                speak(data);
            } else if (data.type === 'stop') {
                if (synth.speaking) synth.cancel();
            }
        };

        connect();
    </script>
</body>
</html>